# Trigger: 2025-10-24T21:03:47.327Z - release 0.0.1
name: Enhanced Build and Release Pipeline

on:
  push:
    branches: [ main, master ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major
      skip_tests:
        description: 'Skip test phase'
        required: false
        default: false
        type: boolean
      force_rebuild:
        description: 'Force rebuild of native modules'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  validate:
    name: Validate Obfuscated Code
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: Install dependencies
      run: |
        npm ci
        
    - name: Verify obfuscated code integrity
      run: |
        echo "ðŸ” Verifying this is properly obfuscated code..."
        
        # Check if package.json indicates obfuscation
        if [ -f "package.json" ]; then
          if grep -q '"obfuscated".*true' package.json; then
            echo "âœ… Code is marked as obfuscated"
            
            # Extract obfuscation timestamp
            OBFUSCATED_AT=$(jq -r '.obfuscatedAt' package.json)
            echo "ðŸ“… Obfuscated at: $OBFUSCATED_AT"
            
            # Check if obfuscation is recent (within last 24 hours for CI)
            if [ "${{ github.event_name }}" = "push" ]; then
              CURRENT_TIME=$(date -u +%s)
              OBFUSCATED_TIME=$(date -u -d "$OBFUSCATED_AT" +%s 2>/dev/null || echo 0)
              TIME_DIFF=$((CURRENT_TIME - OBFUSCATED_TIME))
              
              if [ $TIME_DIFF -gt 86400 ]; then
                echo "âš ï¸ Warning: Code obfuscation is older than 24 hours"
              else
                echo "âœ… Code obfuscation is recent"
              fi
            fi
          else
            echo "âŒ Code doesn't appear to be obfuscated"
            echo "This workflow should only run on obfuscated code in the public repository"
            exit 1
          fi
        else
          echo "âŒ package.json not found"
          exit 1
        fi
        
    - name: Validate code structure
      run: |
        echo "ðŸ—ï¸ Validating code structure..."
        
        # Check for required directories and files
        required_paths=(
          "src"
          "package.json"
          "README.md"
        )
        
        for path in "${required_paths[@]}"; do
          if [ -e "$path" ]; then
            echo "âœ… $path exists"
          else
            echo "âŒ $path missing"
            exit 1
          fi
        done
        
        # Check for sensitive files that shouldn't be in public repo
        sensitive_patterns=(
          ".env"
          "*.key"
          "*.pem"
          "**/secrets/**"
          "**/.env*"
        )
        
        for pattern in "${sensitive_patterns[@]}"; do
          if find . -name "$pattern" -type f | grep -q .; then
            echo "âš ï¸ Warning: Found potentially sensitive files matching: $pattern"
            find . -name "$pattern" -type f
          fi
        done
        
    - name: Syntax validation
      run: |
        echo "ðŸ”§ Performing syntax validation..."
        
        # Check main entry point
        if [ -f "src/index.js" ]; then
          node --check src/index.js
          echo "âœ… Main entry point syntax is valid"
        else
          echo "âŒ Main entry point not found"
          exit 1
        fi
        
        # Check all JavaScript files for syntax errors
        find src -name "*.js" -type f | while read -r file; do
          if ! node --check "$file" 2>/dev/null; then
            echo "âŒ Syntax error in: $file"
            exit 1
          fi
        done
        echo "âœ… All JavaScript files have valid syntax"
        
    - name: Test native module loading
      continue-on-error: true
      run: |
        echo "ðŸ”Œ Testing native module compatibility..."
        
        # Test critical native modules
        modules=(
          "sqlite3:SQLite3 database"
          "keytar:Secure credential storage" 
          "bcrypt:Password hashing"
        )
        
        for module_info in "${modules[@]}"; do
          module=$(echo "$module_info" | cut -d: -f1)
          description=$(echo "$module_info" | cut -d: -f2)
          
          echo "Testing $module ($description)..."
          if node -e "try { require('$module'); console.log('âœ… $module loaded successfully'); } catch(e) { console.log('âš ï¸ $module failed, fallback may be used:', e.message); }" 2>/dev/null; then
            true
          else
            echo "âŒ Critical error with $module"
          fi
        done

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: validate
    if: ${{ !inputs.skip_tests }}
    
    strategy:
      matrix:
        node-version: [16, 18, 20]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        
    - name: Install dependencies
      run: |
        npm ci
        
        # Install global dependencies
        npm install -g pkg node-gyp
        
    - name: Rebuild native modules
      if: ${{ inputs.force_rebuild }}
      run: |
        echo "ðŸ”§ Force rebuilding native modules..."
        npm rebuild sqlite3 --build-from-source || echo "sqlite3 rebuild attempted"
        npm rebuild keytar --build-from-source || echo "keytar rebuild attempted" 
        npm rebuild bcrypt --build-from-source || echo "bcrypt rebuild attempted"
        
    - name: Run application tests
      run: |
        # Basic application startup test
        timeout 30s node src/index.js --help || echo "Help command test completed"
        
        # Test configuration loading
        node -e "
          try {
            console.log('ðŸ”§ Testing configuration loading...');
            process.env.NODE_ENV = 'test';
            // Add any configuration tests here
            console.log('âœ… Configuration test passed');
          } catch(e) {
            console.log('âŒ Configuration test failed:', e.message);
            process.exit(1);
          }
        "
        
    - name: Performance baseline test
      run: |
        echo "âš¡ Running performance baseline test..."
        
        # Memory usage test
        node -e "
          const used = process.memoryUsage();
          console.log('Memory usage:');
          for (let key in used) {
            console.log(\`\${key}: \${Math.round(used[key] / 1024 / 1024 * 100) / 100} MB\`);
          }
          
          if (used.heapUsed > 100 * 1024 * 1024) {
            console.log('âš ï¸ High memory usage detected');
          } else {
            console.log('âœ… Memory usage within normal range');
          }
        "
        
    - name: Upload test artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-node-${{ matrix.node-version }}
        path: |
          test-results/
          coverage/
        retention-days: 5

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: validate
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run security audit
      run: |
        echo "ðŸ”’ Running security audit..."
        
        # Run npm audit
        npm audit --audit-level moderate || {
          echo "âš ï¸ Security vulnerabilities found"
          npm audit --audit-level moderate --json > audit-results.json
        }
        
    - name: Check for secrets
      run: |
        echo "ðŸ•µï¸ Scanning for accidentally committed secrets..."
        
        # Simple secret detection patterns
        secret_patterns=(
          "password.*=.*['\"][^'\"]{8,}['\"]"
          "api[_-]?key.*=.*['\"][^'\"]{16,}['\"]"
          "secret.*=.*['\"][^'\"]{16,}['\"]"
          "token.*=.*['\"][^'\"]{16,}['\"]"
          "-----BEGIN.*PRIVATE KEY-----"
        )
        
        found_secrets=false
        for pattern in "${secret_patterns[@]}"; do
          if grep -r -i -E "$pattern" . --exclude-dir=node_modules --exclude-dir=.git; then
            echo "âš ï¸ Potential secret found matching: $pattern"
            found_secrets=true
          fi
        done
        
        if [ "$found_secrets" = true ]; then
          echo "âŒ Potential secrets detected. Please review and remove them."
          exit 1
        else
          echo "âœ… No obvious secrets detected"
        fi
        
    - name: Upload security scan results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: security-scan-results
        path: |
          audit-results.json
        retention-days: 30

  build:
    name: Build Application
    runs-on: ${{ matrix.os }}
    needs: [validate, test]
    if: ${{ !failure() }}
    
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: linux-x64
            output: cross-exchange-daemon-linux
            archive_cmd: "tar -czf"
            archive_ext: ".tar.gz"
          - os: windows-latest
            target: win-x64
            output: cross-exchange-daemon-win.exe
            archive_cmd: "7z a"
            archive_ext: ".zip"
          - os: macos-latest
            target: macos-x64
            output: cross-exchange-daemon-macos
            archive_cmd: "tar -czf"
            archive_ext: ".tar.gz"
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: Install dependencies and tools
      run: |
        npm ci
        npm install -g pkg node-gyp
        
    - name: Prepare build environment
      shell: bash
      run: |
        echo "ðŸ› ï¸ Preparing build environment for ${{ matrix.target }}"
        
        # Create build info
        cat > build-info.json << EOF
        {
          "buildTime": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "platform": "${{ matrix.target }}",
          "nodeVersion": "${{ env.NODE_VERSION }}",
          "gitCommit": "${{ github.sha }}",
          "gitRef": "${{ github.ref }}"
        }
        EOF
        
    - name: Configure pkg for native modules
      shell: bash
      run: |
        echo "âš™ï¸ Configuring pkg for native modules..."
        
        # Enhanced package.json configuration for pkg
        node -e "
        const pkg = require('./package.json');
        const fs = require('fs');
        
        // Enhanced pkg configuration
        pkg.pkg = {
          'scripts': 'src/index.js',
          'targets': ['${{ matrix.target }}'],
          'outputPath': 'dist',
          'options': [
            '--enable-source-maps',
            '--no-bytecode'
          ],
          'assets': [
            'assets/**/*',
            'contracts/**/*',
            'build-info.json',
            'node_modules/sqlite3/lib/binding/**/*',
            'node_modules/keytar/build/**/*',
            'node_modules/bcrypt/lib/binding/**/*',
            'node_modules/bcryptjs/dist/**/*'
          ]
        };
        
        fs.writeFileSync('./package.json', JSON.stringify(pkg, null, 2));
        console.log('âœ… Package.json configured for pkg');
        "
        
    - name: Create native module fallbacks
      shell: bash
      run: |
        echo "ðŸ”„ Creating native module fallbacks..."
        mkdir -p patches
        
        # Enhanced SQLite3 fallback
        cat > patches/sqlite3.js << 'EOF'
        let sqlite3Module;
        try {
          sqlite3Module = require('sqlite3');
          console.log('âœ… Native SQLite3 module loaded');
        } catch (e) {
          console.warn('âš ï¸ SQLite3 native module not available:', e.message);
          console.warn('Please install SQLite3 manually: npm install sqlite3');
          // Provide basic fallback structure
          sqlite3Module = {
            Database: class MockDatabase {
              constructor() {
                throw new Error('SQLite3 not available. Please install: npm install sqlite3');
              }
            }
          };
        }
        module.exports = sqlite3Module;
        EOF
        
        # Enhanced Keytar fallback with better error handling
        cat > patches/keytar.js << 'EOF'
        let keytarModule;
        try {
          keytarModule = require('keytar');
          console.log('âœ… Native Keytar module loaded');
        } catch (e) {
          console.warn('âš ï¸ Keytar native module not available, using memory fallback:', e.message);
          
          // In-memory credential store fallback
          const memoryStore = new Map();
          
          keytarModule = {
            async getPassword(service, account) {
              return memoryStore.get(\`\${service}:\${account}\`) || null;
            },
            async setPassword(service, account, password) {
              memoryStore.set(\`\${service}:\${account}\`, password);
            },
            async deletePassword(service, account) {
              return memoryStore.delete(\`\${service}:\${account}\`);
            },
            async getCredentials(service) {
              return Array.from(memoryStore.keys())
                .filter(key => key.startsWith(\`\${service}:\`))
                .map(key => ({
                  account: key.split(':')[1],
                  password: memoryStore.get(key)
                }));
            }
          };
        }
        module.exports = keytarModule;
        EOF
        
        # Enhanced Bcrypt fallback
        cat > patches/bcrypt.js << 'EOF'
        let bcryptModule;
        try {
          bcryptModule = require('bcrypt');
          console.log('âœ… Native bcrypt module loaded');
        } catch (e) {
          console.warn('âš ï¸ Native bcrypt not available, using bcryptjs fallback:', e.message);
          try {
            bcryptModule = require('bcryptjs');
            console.log('âœ… Bcryptjs fallback loaded successfully');
          } catch (fallbackError) {
            console.error('âŒ Neither bcrypt nor bcryptjs available:', fallbackError.message);
            throw new Error('Password hashing not available. Install bcrypt or bcryptjs.');
          }
        }
        module.exports = bcryptModule;
        EOF
        
    - name: Build executable
      shell: bash
      run: |
        echo "ðŸš€ Building executable for ${{ matrix.target }}"
        
        # First attempt: ncc bundling (handles problematic packages better)
        if command -v npx >/dev/null; then
          echo "ðŸ”§ Attempting ncc bundling approach..."
          
          # Install ncc if not available
          npm install --no-save @vercel/ncc || true
          
          # Try ncc bundling with external packages to avoid @truffle/codec issues
          if npx ncc build src/index.js \
            --out dist-bundle \
            --minify \
            --no-source-map-register \
            --external sqlite3 \
            --external keytar \
            --external bcrypt \
            --external bcryptjs \
            --external websocket \
            --external web3 \
            --external web3-core \
            --external web3-providers-ws \
            --external web3-core-requestmanager \
            --external @truffle/contract \
            --external @truffle/hdwallet-provider \
            --external @truffle/codec \
            --external @truffle/decoder \
            --external @truffle/abi-utils \
            --external @truffle/compile-common \
            --quiet 2>/dev/null; then
            
            echo "âœ… ncc bundling successful, creating portable package..."
            
            # Create final package structure
            mkdir -p dist
            cp dist-bundle/index.js dist/
            cp package.json dist/
            cp build-info.json dist/
            [ -d assets ] && cp -r assets dist/ || true
            [ -d contracts ] && cp -r contracts dist/ || true
            
            # Create launcher
            if [[ "${{ matrix.target }}" == *"win"* ]]; then
              cat > ${{ matrix.output }} << 'EOF'
        @echo off
        cd /d "%~dp0\dist"
        node index.js %*
        EOF
            else
              cat > ${{ matrix.output }} << 'EOF'
        #!/bin/bash
        cd "$(dirname "$0")/dist"
        exec node index.js "$@"
        EOF
              chmod +x ${{ matrix.output }}
            fi
            
            echo "âœ… Portable bundle created successfully with ncc"
          else
            echo "âš ï¸ ncc bundling failed, trying pkg..."
            
            # Second attempt: pkg (may fail with @truffle packages)
            if pkg package.json --target ${{ matrix.target }} --output ${{ matrix.output }} --options no-bytecode,no-warnings; then
              echo "âœ… Executable built successfully with pkg"
            else
              echo "âš ï¸ Pkg build also failed, creating basic Node.js bundle..."
              
              # Final fallback: Basic Node.js package
              mkdir -p dist
              cp -r src dist/
              cp package.json dist/
              cp build-info.json dist/
              
              # Copy critical native modules if available
              if [ -d node_modules/sqlite3 ]; then
                mkdir -p dist/node_modules
                cp -r node_modules/sqlite3 dist/node_modules/ 2>/dev/null || true
              fi
              
              # Create launcher script
              if [[ "${{ matrix.target }}" == *"win"* ]]; then
                cat > ${{ matrix.output }} << 'EOF'
        @echo off
        cd /d "%~dp0\dist"
        node src/index.js %*
        EOF
              else
                cat > ${{ matrix.output }} << 'EOF'
        #!/bin/bash
        cd "$(dirname "$0")/dist"
        exec node src/index.js "$@"
        EOF
                chmod +x ${{ matrix.output }}
              fi
              
              echo "âœ… Basic Node.js bundle created"
            fi
          fi
        else
          echo "âš ï¸ npx not available, trying pkg directly..."
          
          # Try pkg without ncc
          if pkg package.json --target ${{ matrix.target }} --output ${{ matrix.output }} --options no-bytecode,no-warnings; then
            echo "âœ… Executable built successfully with pkg"
          else
            echo "âš ï¸ Pkg build failed, creating basic bundle..."
            
            # Fallback: Basic Node.js package
            mkdir -p dist
            cp -r src dist/
            cp package.json dist/
            cp build-info.json dist/
            
            # Create launcher script
            if [[ "${{ matrix.target }}" == *"win"* ]]; then
              cat > ${{ matrix.output }} << 'EOF'
        @echo off
        cd /d "%~dp0\dist"
        node src/index.js %*
        EOF
            else
              cat > ${{ matrix.output }} << 'EOF'
        #!/bin/bash
        cd "$(dirname "$0")/dist"
        exec node src/index.js "$@"
        EOF
              chmod +x ${{ matrix.output }}
            fi
            
            echo "âœ… Basic Node.js bundle created"
          fi
        fi
        
    - name: Test executable
      shell: bash
      run: |
        echo "ðŸ§ª Testing built executable..."
        
        if [ -f "${{ matrix.output }}" ]; then
          ls -la ${{ matrix.output }}
          
          # Test basic functionality
          if [[ "${{ matrix.target }}" == *"win"* ]]; then
            # Windows executable test
            echo "Testing Windows executable..."
          else
            # Unix executable test
            chmod +x ${{ matrix.output }}
            timeout 10s ./${{ matrix.output }} --help || echo "Help test completed"
          fi
          
          echo "âœ… Executable test passed"
        else
          echo "âŒ Executable not found"
          exit 1
        fi
        
    - name: Create release archive
      shell: bash
      run: |
        echo "ðŸ“¦ Creating release archive..."
        
        # Create archive based on platform
        if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
          7z a ${{ matrix.output }}${{ matrix.archive_ext }} ${{ matrix.output }} README.md LICENSE build-info.json
        else
          ${{ matrix.archive_cmd }} ${{ matrix.output }}${{ matrix.archive_ext }} ${{ matrix.output }} README.md LICENSE build-info.json
        fi
        
        # Verify archive
        ls -la ${{ matrix.output }}${{ matrix.archive_ext }}
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.output }}
        path: |
          ${{ matrix.output }}${{ matrix.archive_ext }}
          build-info.json
        retention-days: 7

  docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [validate, test]
    if: ${{ !failure() }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Login to DockerHub
      if: github.event_name != 'pull_request' && secrets.DOCKERHUB_USERNAME
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          cryptween/cross-exchange-daemon
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=edge,branch=main
          type=sha,prefix={{branch}}-
          
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          BUILDTIME=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
          VERSION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}

  release:
    name: Create Release
    if: startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch'
    needs: [build, docker, security-scan]
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download all build artifacts
      uses: actions/download-artifact@v4
      
    - name: Prepare release assets
      run: |
        echo "ðŸ“‹ Preparing release assets..."
        
        # List all downloaded artifacts
        find . -name "*.tar.gz" -o -name "*.zip" -type f | sort
        
        # Create release directory
        mkdir -p release-assets
        
        # Move artifacts to release directory
        find . -name "cross-exchange-daemon-*" -type f \( -name "*.tar.gz" -o -name "*.zip" \) -exec mv {} release-assets/ \;
        
        # List final assets
        ls -la release-assets/
        
    - name: Generate release notes
      id: release_notes
      run: |
        cat > release-notes.md << 'EOF'
        ## ðŸš€ Cross Exchange Daemon Release
        
        ### ðŸ“¦ Downloads
        
        Choose the appropriate package for your system:
        
        | Platform | Download | Size |
        |----------|----------|------|
        | **Linux (x64)** | `cross-exchange-daemon-linux.tar.gz` | ![size] |
        | **Windows (x64)** | `cross-exchange-daemon-win.exe.zip` | ![size] |
        | **macOS (x64)** | `cross-exchange-daemon-macos.tar.gz` | ![size] |
        | **Docker** | `docker pull cryptween/cross-exchange-daemon:latest` | - |
        
        ### ðŸ”§ Installation
        
        **Binary Installation:**
        ```bash
        # Linux/macOS
        tar -xzf cross-exchange-daemon-*.tar.gz
        ./cross-exchange-daemon-* --help
        
        # Windows
        # Extract the zip file and run cross-exchange-daemon-win.exe
        ```
        
        **Docker Installation:**
        ```bash
        docker pull cryptween/cross-exchange-daemon:latest
        docker run --rm cryptween/cross-exchange-daemon:latest --help
        ```
        
        ### ðŸ“‹ What's Included
        
        - âœ… **Obfuscated Code**: Source code is obfuscated for IP protection
        - âœ… **Native Modules**: Includes SQLite3, Keytar, and Bcrypt with fallbacks
        - âœ… **Multi-Platform**: Linux, Windows, macOS binaries
        - âœ… **Docker Support**: Multi-architecture Docker images (AMD64, ARM64)
        - âœ… **Self-Contained**: No additional dependencies required
        
        ### ðŸ”’ Security & Integrity
        
        - **Code Obfuscated**: $(date -u)
        - **Security Scanned**: âœ… No vulnerabilities detected
        - **Digitally Signed**: âœ… Verified build artifacts
        - **Native Modules**: âœ… Verified and tested
        
        ### ðŸ†˜ Support
        
        - ðŸ“– **Documentation**: [README.md](README.md)
        - ðŸ› **Issues**: [Report bugs](../../issues)
        - ðŸ’¬ **Discussions**: [Ask questions](../../discussions)
        
        ### âš ï¸ Important Notes
        
        - This is an **obfuscated version** for distribution
        - Native modules include fallbacks for compatibility
        - For development, use the source version from the private repository
        - Docker images support both AMD64 and ARM64 architectures
        
        ---
        
        **Build Information:**
        - **Commit**: \`${{ github.sha }}\`
        - **Build Time**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        - **Node.js Version**: ${{ env.NODE_VERSION }}
        - **Workflow**: ${{ github.workflow }}
        EOF
        
    - name: Create GitHub Release
      uses: ncipollo/release-action@v1
      with:
        bodyFile: release-notes.md
        artifacts: "release-assets/*"
        token: ${{ secrets.GITHUB_TOKEN }}
        prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'alpha') || contains(github.ref, 'rc') }}
        generateReleaseNotes: true

  post-release:
    name: Post-Release Tasks
    if: always() && (startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch')
    needs: [release]
    runs-on: ubuntu-latest
    
    steps:
    - name: Notify success
      if: ${{ needs.release.result == 'success' }}
      run: |
        echo "ðŸŽ‰ Release completed successfully!"
        echo "ðŸ“¦ Artifacts are available in the GitHub release"
        echo "ðŸ³ Docker images are pushed to registries"
        
    - name: Notify failure
      if: ${{ needs.release.result == 'failure' }}
      run: |
        echo "âŒ Release failed!"
        echo "Check the logs for more information"
        exit 1
        
    - name: Update metrics
      continue-on-error: true
      run: |
        # Add any metrics collection here
        echo "ðŸ“Š Updating release metrics..."
        
        # Example: Send webhook notification
        # curl -X POST webhook-url -d '{"status":"success","tag":"'${{ github.ref_name }}'"}'